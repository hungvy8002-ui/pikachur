<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pikachur Classic — Levels (Web)</title>
<style>
  :root{
    --bg:#071024; --card:#0f1724; --accent:#ffd54a; --muted:#9aa4b2;
    --tile-size:72px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071025 0%, #0f1720 100%);color:#e6eef6}
  .wrap{max-width:1100px;margin:16px auto;padding:18px}
  header{display:flex;gap:12px;align-items:center}
  header img{height:56px}
  h1{font-size:20px;margin:0}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:12px 0}
  .controls input[type="number"]{width:64px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  button{background:var(--card);border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
  button:hover{transform:translateY(-2px)}
  .board-wrap{background:rgba(255,255,255,0.02);padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  .board{display:grid;gap:8px;justify-items:center;padding:8px}
  .tile{width:var(--tile-size);height:var(--tile-size);border-radius:8px;background:#fff;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.45);transition:transform .18s ease,opacity .18s ease}
  .tile img{max-width:100%;max-height:100%;object-fit:contain;display:block}
  .tile.empty{background:transparent;box-shadow:none;cursor:default}
  .tile.matched{opacity:0;transform:scale(.6)}
  .tile.selected{outline:3px solid rgba(255,213,74,0.95);transform:translateY(-6px)}
  .hud{display:flex;gap:12px;align-items:center;margin-top:10px;color:var(--muted);flex-wrap:wrap}
  .muted{color:var(--muted)}
  #canvasLayer{position:absolute;left:0;top:0;pointer-events:none}
  .board-stage{position:relative}
  .levelBox{display:flex;gap:8px;align-items:center}
  .big{font-size:18px;font-weight:600}
  .controls .right{margin-left:auto;display:flex;gap:8px;align-items:center}
  .next-level{background:linear-gradient(90deg,#ffd54a,#ffb347);color:#07213a;border:none}
  @media (max-width:840px){
    :root{--tile-size:56px}
  }
  @media (max-width:480px){
    :root{--tile-size:44px}
    header img{height:44px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <img src="assets/button/gameName.png" alt="game" onerror="this.style.display='none'"/>
      <div>
        <h1>Pikachur Classic — Levels</h1>
        <div class="muted">Connect-2 (≤2 góc). Tăng ô theo level. Không có âm nhạc.</div>
      </div>
    </header>

    <div class="controls">
      <div class="levelBox">
        <div class="muted">Level</div>
        <div id="levelLabel" class="big">1</div>
      </div>

      <div class="muted">Start size:</div>
      <div class="muted">6×8 → mỗi level +2 hàng +2 cột</div>

      <div class="controls right">
        <button id="prevLevelBtn">« Level trước</button>
        <button id="nextLevelBtn">Level tiếp →</button>
        <button id="newBtn">Tạo lại</button>
        <button id="shuffleBtn">Xáo</button>
        <button id="hintBtn">Gợi ý</button>
        <div id="remaining" class="muted">Còn: 0 ô</div>
      </div>
    </div>

    <div class="board-wrap">
      <div class="board-stage" id="stage">
        <canvas id="canvasLayer"></canvas>
        <div id="board" class="board"></div>
      </div>
    </div>

    <div class="hud">
      <div class="muted">Luật: chọn 2 ô giống nhau. Hai ô phải nối được bằng đường gồm ≤2 góc (không cắt ô khác).</div>
      <div class="muted">Nếu hết đường, hãy nhấn "Xáo".</div>
    </div>
  </div>

<script>
/*
  Pikachur Classic with leveling (no music).
  Level 1: 6x8. Each next level adds +2 rows and +2 cols.
  Uses images from assets/images/pokemon/{1..N}.png if present.
*/

// Config
const BASE_ROWS = 6;
const BASE_COLS = 8;
const MAX_DETECT = 500; // max images to probe
const stage = document.getElementById('stage');
const boardEl = document.getElementById('board');
const canvas = document.getElementById('canvasLayer');
const levelLabel = document.getElementById('levelLabel');
const remainingEl = document.getElementById('remaining');
const newBtn = document.getElementById('newBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const hintBtn = document.getElementById('hintBtn');
const prevLevelBtn = document.getElementById('prevLevelBtn');
const nextLevelBtn = document.getElementById('nextLevelBtn');

let level = 1;
let rows = BASE_ROWS, cols = BASE_COLS;
let grid = []; // with padding
let moves = 0;
let availableImages = [];

// detect available images (best-effort); returns array of path strings
async function detectImages(){
  const arr = [];
  for (let i=1;i<=MAX_DETECT;i++){
    const p = `assets/images/pokemon/${i}.png`;
    try {
      const r = await fetch(p, {method:'GET'});
      if (r.ok) arr.push(p);
    } catch(e){
      // ignore; continue trying next indices (some hosts may 404 quickly)
    }
  }
  return arr;
}

// shuffle util
function shuffle(a){ for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

// prepare pairs list for N cells (must be even)
function preparePairsList(avail, cellCount){
  const pairs = Math.floor(cellCount/2);
  const list = [];
  if (avail.length >= pairs){
    const pick = shuffle(avail.slice()).slice(0,pairs);
    for (let i=0;i<pick.length;i++){ list.push(pick[i]); list.push(pick[i]); }
  } else if (avail.length > 0){
    // reuse available to fill
    let i=0;
    while (list.length < pairs*2){
      list.push(avail[i % avail.length]);
      list.push(avail[i % avail.length]);
      i++;
    }
  } else {
    // no images: use null placeholders
    for (let i=0;i<pairs;i++){ list.push(null); list.push(null); }
  }
  return shuffle(list);
}

// create grid with padding border of 1
function buildGrid(rowsNoPad, colsNoPad, pairsList){
  const R = rowsNoPad + 2, C = colsNoPad + 2;
  const g = Array.from({length:R}, ()=> Array.from({length:C}, ()=> ({img:null, matched:true})));
  let k=0;
  for (let r=1;r<=rowsNoPad;r++){
    for (let c=1;c<=colsNoPad;c++){
      g[r][c] = { img: pairsList[k]===undefined?null:pairsList[k], matched:false };
      k++;
    }
  }
  return g;
}

// render board DOM
function renderBoard(){
  const innerRows = grid.length - 2;
  const innerCols = grid[0].length - 2;
  boardEl.style.gridTemplateColumns = `repeat(${innerCols}, 1fr)`;
  boardEl.innerHTML = '';
  for (let r=1;r<=innerRows;r++){
    for (let c=1;c<=innerCols;c++){
      const cell = grid[r][c];
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.r = r; tile.dataset.c = c;
      if (cell.matched) { tile.classList.add('empty'); tile.classList.add('matched');}
      if (cell.img){
        const img = document.createElement('img');
        img.src = cell.img;
        img.alt='';
        img.onerror = function(){ this.style.display='none'; };
        tile.appendChild(img);
      } else {
        tile.innerHTML = `<div style="font-size:22px;color:#2b2b2b">?</div>`;
      }
      tile.addEventListener('click', onTileClick);
      boardEl.appendChild(tile);
    }
  }
  resizeCanvas();
  updateRemaining();
}

function updateRemaining(){
  let cnt=0;
  for (let r=1;r<grid.length-1;r++) for (let c=1;c<grid[0].length-1;c++) if (!grid[r][c].matched) cnt++;
  remainingEl.textContent = `Còn: ${cnt} ô — Lượt: ${moves}`;
}

// click logic with selection + path check
let firstSel = null;
let busy = false;
function onTileClick(e){
  if (busy) return;
  const el = e.currentTarget;
  const r = +el.dataset.r, c = +el.dataset.c;
  if (grid[r][c].matched) return;
  if (!firstSel){
    firstSel = {r,c,el};
    el.classList.add('selected');
    return;
  }
  // second pick
  if (firstSel.r === r && firstSel.c === c){
    firstSel.el.classList.remove('selected');
    firstSel = null; return;
  }
  const a = firstSel, b = {r,c,el};
  a.el.classList.add('selected');
  b.el.classList.add('selected');
  moves++;
  const cellA = grid[a.r][a.c], cellB = grid[b.r][b.c];
  const same = (cellA.img && cellB.img && cellA.img === cellB.img) || (!cellA.img && !cellB.img);
  if (!same){
    setTimeout(()=>{ a.el.classList.remove('selected'); b.el.classList.remove('selected'); firstSel=null; }, 350);
    return;
  }
  // check connectivity
  const path = findPath(a.r,a.c,b.r,b.c);
  if (path){
    busy = true;
    drawPath(path);
    setTimeout(()=> {
      // animate matched: add class then remove cell
      a.el.classList.add('matched'); b.el.classList.add('matched');
      grid[a.r][a.c].matched = true;
      grid[b.r][b.c].matched = true;
      firstSel = null;
      renderBoard();
      busy = false;
      updateRemaining();
      if (isWin()) {
        // show next-level button/promote
        setTimeout(()=> {
          const proceed = confirm('Bạn đã hoàn thành level ' + level + '. Chuyển level tiếp?');
          if (proceed) nextLevel();
        }, 100);
      }
    }, 260);
  } else {
    setTimeout(()=>{ a.el.classList.remove('selected'); b.el.classList.remove('selected'); firstSel=null; }, 350);
  }
}

// pathfinding allowing <=2 turns (BFS)
function findPath(r1,c1,r2,c2){
  if (r1===r2 && c1===c2) return null;
  const R = grid.length, C = grid[0].length;
  const dirs = [{dr:-1,dc:0},{dr:0,dc:1},{dr:1,dc:0},{dr:0,dc:-1}];
  const INF = 999;
  const best = Array.from({length:R}, ()=> Array.from({length:C}, ()=> Array(4).fill(INF)));
  const q = [];
  const parent = new Map();
  const key = s=>`${s.r},${s.c},${s.dir},${s.turns}`;
  for (let d=0;d<4;d++){
    best[r1][c1][d] = 0;
    q.push({r:r1,c:c1,dir:d,turns:0});
    parent.set(key({r:r1,c:c1,dir:d,turns:0}), null);
  }
  while (q.length){
    const cur = q.shift();
    let nr = cur.r + dirs[cur.dir].dr, nc = cur.c + dirs[cur.dir].dc;
    while (nr>=0 && nr<R && nc>=0 && nc<C){
      const cell = grid[nr][nc];
      const occupied = !cell.matched;
      const isTarget = (nr===r2 && nc===c2);
      if (occupied && !isTarget) break;
      if (best[nr][nc][cur.dir] > cur.turns){
        best[nr][nc][cur.dir] = cur.turns;
        parent.set(key({r:nr,c:nc,dir:cur.dir,turns:cur.turns}), key(cur));
        if (nr===r2 && nc===c2 && cur.turns<=2){
          return reconstructPath(parent, {r:nr,c:nc,dir:cur.dir,turns:cur.turns}, {r:r1,c:c1});
        }
        if (cur.turns < 2){
          for (let nd=0;nd<4;nd++){
            if (nd===cur.dir) continue;
            const nt = cur.turns + 1;
            if (best[nr][nc][nd] > nt){
              best[nr][nc][nd] = nt;
              parent.set(key({r:nr,c:nc,dir:nd,turns:nt}), key(cur));
              q.push({r:nr,c:nc,dir:nd,turns:nt});
            }
          }
        }
        q.push({r:nr,c:nc,dir:cur.dir,turns:cur.turns});
      }
      nr += dirs[cur.dir].dr; nc += dirs[cur.dir].dc;
    }
  }
  return null;
}

function reconstructPath(parentMap, endState, startPos){
  const key = s=>`${s.r},${s.c},${s.dir},${s.turns}`;
  const pts = [];
  let curKey = key(endState);
  while (curKey){
    const parts = curKey.split(',').map(Number);
    pts.push({r:parts[0],c:parts[1]});
    curKey = parentMap.get(curKey);
  }
  if (pts.length===0 || pts[pts.length-1].r !== startPos.r || pts[pts.length-1].c !== startPos.c){
    pts.push({r:startPos.r,c:startPos.c});
  }
  pts.reverse();
  // compress to turning points
  const comp = [];
  for (const p of pts){
    if (!comp.length) { comp.push(p); continue; }
    if (comp.length>=2){
      const a = comp[comp.length-2], b = comp[comp.length-1];
      const daR = b.r - a.r, daC = b.c - a.c;
      const dbR = p.r - b.r, dbC = p.c - b.c;
      if (Math.sign(daR) === Math.sign(dbR) && Math.sign(daC) === Math.sign(dbC)){
        comp[comp.length-1] = p;
      } else comp.push(p);
    } else comp.push(p);
  }
  return comp;
}

// drawing path on canvas
function drawPath(points){
  resizeCanvas();
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (!points || points.length<2) return;
  const coords = points.map(p=>tileCenterXY(p.r,p.c));
  ctx.lineWidth = 4;
  ctx.strokeStyle = 'rgba(255,213,74,0.98)';
  ctx.fillStyle = 'rgba(255,213,74,0.98)';
  ctx.beginPath();
  ctx.moveTo(coords[0].x, coords[0].y);
  for (let i=1;i<coords.length;i++) ctx.lineTo(coords[i].x, coords[i].y);
  ctx.stroke();
  for (let p of coords){ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); }
  setTimeout(()=>{ canvas.getContext('2d').clearRect(0,0,canvas.width,canvas.height); }, 420);
}

// compute center XY of tile relative to stage
function tileCenterXY(r,c){
  const tile = boardEl.querySelector(`.tile[data-r='${r}'][data-c='${c}']`);
  const stageRect = stage.getBoundingClientRect();
  if (!tile) return {x:0,y:0};
  const tr = tile.getBoundingClientRect();
  return { x: (tr.left - stageRect.left) + tr.width/2, y: (tr.top - stageRect.top) + tr.height/2 };
}

// resize canvas overlay
function resizeCanvas(){
  const rect = stage.getBoundingClientRect();
  canvas.width = rect.width * devicePixelRatio;
  canvas.height = rect.height * devicePixelRatio;
  canvas.style.width = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  const ctx = canvas.getContext('2d');
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}

// shuffle remaining unmatched
function shuffleRemaining(){
  const arr = [];
  for (let r=1;r<grid.length-1;r++) for (let c=1;c<grid[0].length-1;c++) if (!grid[r][c].matched) arr.push(grid[r][c].img);
  shuffle(arr);
  let k=0;
  for (let r=1;r<grid.length-1;r++) for (let c=1;c<grid[0].length-1;c++) if (!grid[r][c].matched) grid[r][c].img = arr[k++];
  renderBoard();
}

// find any connectable pair for hint
function findHint(){
  for (let r1=1;r1<grid.length-1;r1++){
    for (let c1=1;c1<grid[0].length-1;c1++){
      const a = grid[r1][c1]; if (a.matched) continue;
      for (let r2=r1;r2<grid.length-1;r2++){
        for (let c2=(r2===r1?c1+1:1); c2<grid[0].length-1;c2++){
          const b = grid[r2][c2]; if (b.matched) continue;
          const same = (a.img && b.img && a.img===b.img) || (!a.img && !b.img);
          if (!same) continue;
          const p = findPath(r1,c1,r2,c2);
          if (p) return {a:{r:r1,c:c1}, b:{r:r2,c:c2}, path:p};
        }
      }
    }
  }
  return null;
}

// check if no moves left (no connectable pairs)
function hasPossibleMove(){
  return !!findHint();
}

function isWin(){
  for (let r=1;r<grid.length-1;r++) for (let c=1;c<grid[0].length-1;c++) if (!grid[r][c].matched) return false;
  return true;
}

// level logic
function applyLevel(lv){
  level = lv;
  levelLabel.textContent = lv;
  rows = BASE_ROWS + (lv-1)*2;
  cols = BASE_COLS + (lv-1)*2;
}

// start a level
function startLevel(lv){
  applyLevel(lv);
  moves = 0;
  initializeBoard();
}

async function initializeBoard(){
  // detect images the first time
  if (!availableImages.length) availableImages = await detectImages();
  const cells = rows * cols;
  const pairsList = preparePairsList(availableImages, cells);
  grid = buildGrid(rows, cols, pairsList);
  renderBoard();
  // if no possible moves at start, shuffle
  if (!hasPossibleMove()) shuffleRemaining();
}

// UI events
newBtn.addEventListener('click', ()=> startLevel(level));
shuffleBtn.addEventListener('click', ()=> shuffleRemaining());
hintBtn.addEventListener('click', ()=>{
  const h = findHint();
  if (!h){ alert('Không tìm thấy cặp gợi ý. Hãy xáo bài.'); return; }
  const t1 = boardEl.querySelector(`.tile[data-r='${h.a.r}'][data-c='${h.a.c}']`);
  const t2 = boardEl.querySelector(`.tile[data-r='${h.b.r}'][data-c='${h.b.c}']`);
  if (t1 && t2){
    t1.classList.add('selected'); t2.classList.add('selected');
    drawPath(h.path);
    setTimeout(()=>{ t1.classList.remove('selected'); t2.classList.remove('selected'); }, 900);
  }
});
prevLevelBtn.addEventListener('click', ()=> { if (level>1) startLevel(level-1); });
nextLevelBtn.addEventListener('click', ()=> startLevel(level+1));

// auto-shuffle when no moves left
function autoShuffleIfStuck(){
  if (!hasPossibleMove()){
    shuffleRemaining();
    return true;
  }
  return false;
}

// on win move to next level prompt
function nextLevel(){ startLevel(level+1); }

// window resize
window.addEventListener('resize', resizeCanvas);

// start first level
startLevel(1);

</script>
</body>
</html>
