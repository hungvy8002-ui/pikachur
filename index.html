<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pikachur Classic — Levels</title>
<style>
:root{
  --bg:#071024; --card:#0f1724; --accent:#ffd54a; --muted:#9aa4b2;
  --tile-size:72px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071025 0%, #0f1720 100%);color:#e6eef6}
.wrap{max-width:1100px;margin:16px auto;padding:18px}
header{display:flex;gap:12px;align-items:center}
header img{height:56px}
h1{font-size:20px;margin:0}
.controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:12px 0}
.controls input[type="number"]{width:64px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
button{background:var(--card);border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
button:hover{transform:translateY(-2px)}
.board-wrap{background:rgba(255,255,255,0.02);padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
.board{display:grid;gap:8px;justify-items:center;padding:8px}
.tile{width:var(--tile-size);height:var(--tile-size);border-radius:8px;background:#fff;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.45);transition:transform .18s ease,opacity .18s ease}
.tile img{max-width:100%;max-height:100%;object-fit:contain;display:block}
.tile.empty{background:transparent;box-shadow:none;cursor:default}
.tile.matched{opacity:0;transform:scale(.6)}
.tile.selected{outline:3px solid rgba(255,213,74,0.95);transform:translateY(-6px)}
.hud{display:flex;gap:12px;align-items:center;margin-top:10px;color:var(--muted);flex-wrap:wrap}
.muted{color:var(--muted)}
#canvasLayer{position:absolute;left:0;top:0;pointer-events:none}
.board-stage{position:relative}
.levelBox{display:flex;gap:8px;align-items:center}
.big{font-size:18px;font-weight:600}
.controls .right{margin-left:auto;display:flex;gap:8px;align-items:center}
.next-level{background:linear-gradient(90deg,#ffd54a,#ffb347);color:#07213a;border:none}
@media (max-width:840px){
  :root{--tile-size:56px}
}
@media (max-width:480px){
  :root{--tile-size:44px}
  header img{height:44px}
}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <img src="assets/button/gameName.png" alt="game" onerror="this.style.display='none'"/>
    <div>
      <h1>Pikachur Classic — Levels</h1>
      <div class="muted">Connect-2 (≤2 góc). Tăng ô theo level. Không có âm nhạc.</div>
    </div>
  </header>

  <div class="controls">
    <div class="levelBox">
      <div class="muted">Level</div>
      <div id="levelLabel" class="big">1</div>
    </div>

    <div class="muted">Start size:</div>
    <div class="muted">6×8 → mỗi level +2 hàng +2 cột</div>

    <div class="controls right">
      <button id="prevLevelBtn">« Level trước</button>
      <button id="nextLevelBtn">Level tiếp →</button>
      <button id="newBtn">Tạo lại</button>
      <button id="shuffleBtn">Xáo</button>
      <button id="hintBtn">Gợi ý</button>
      <div id="remaining" class="muted">Còn: 0 ô</div>
    </div>
  </div>

  <div class="board-wrap">
    <div class="board-stage" id="stage">
      <canvas id="canvasLayer"></canvas>
      <div id="board" class="board"></div>
    </div>
  </div>

  <div class="hud">
    <div class="muted">Luật: chọn 2 ô giống nhau. Hai ô phải nối được bằng đường gồm ≤2 góc (không cắt ô khác).</div>
    <div class="muted">Nếu hết đường, hãy nhấn "Xáo".</div>
  </div>
</div>

<script>
// --- Config ---
const BASE_ROWS = 6, BASE_COLS = 8, MAX_DETECT = 500;
const stage = document.getElementById('stage'), boardEl = document.getElementById('board');
const levelLabel = document.getElementById('levelLabel'), remainingEl = document.getElementById('remaining');
const newBtn = document.getElementById('newBtn'), shuffleBtn = document.getElementById('shuffleBtn');
const hintBtn = document.getElementById('hintBtn'), prevLevelBtn = document.getElementById('prevLevelBtn');
const nextLevelBtn = document.getElementById('nextLevelBtn'), canvas = document.getElementById('canvasLayer');

let level = 1, rows = BASE_ROWS, cols = BASE_COLS, grid = [], moves = 0;
let availableImages = [], firstSel = null, busy = false;
let hintLimit = 3, shuffleLimit = 3;

// --- LocalStorage progress ---
let maxLevelUnlocked = parseInt(localStorage.getItem('pikachur_maxLevel')||'1');
function saveProgress(){ localStorage.setItem('pikachur_maxLevel', maxLevelUnlocked); }
function unlockLevel(lv){ maxLevelUnlocked = Math.max(maxLevelUnlocked, lv); saveProgress(); }

// --- Detect images ---
async function detectImages(){
  const arr = [];
  for(let i=1;i<=MAX_DETECT;i++){
    const p = `assets/images/pokemon/${i}.png`;
    try{ const r = await fetch(p,{method:'GET'}); if(r.ok) arr.push(p); }catch(e){}
  }
  return arr;
}

// --- Utils ---
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
function preparePairsList(avail, cellCount){
  const pairs = Math.floor(cellCount/2), list = [];
  if(avail.length>=pairs){ const pick = shuffle(avail.slice()).slice(0,pairs); for(let i=0;i<pairs;i++){ list.push(pick[i]); list.push(pick[i]); } }
  else if(avail.length>0){ let i=0; while(list.length<pairs*2){ list.push(avail[i%avail.length]); list.push(avail[i%avail.length]); i++; } }
  else { for(let i=0;i<pairs;i++){ list.push("?"); list.push("?"); } }
  return shuffle(list);
}

// --- Build grid ---
function buildGrid(rowsNoPad, colsNoPad, pairsList){
  const R = rowsNoPad+2, C = colsNoPad+2;
  const g = Array.from({length:R},()=>Array.from({length:C},()=>({img:null,matched:true})));
  let k=0;
  for(let r=1;r<=rowsNoPad;r++){
    for(let c=1;c<=colsNoPad;c++){
      g[r][c] = { img: pairsList[k]===undefined?null:pairsList[k], matched:false };
      k++;
    }
  }
  return g;
}

// --- Render board ---
function renderBoard(){
  const innerRows = grid.length-2, innerCols = grid[0].length-2;
  boardEl.style.gridTemplateColumns=`repeat(${innerCols},var(--tile-size))`;
  boardEl.innerHTML='';
  for(let r=1;r<=innerRows;r++){
    for(let c=1;c<=innerCols;c++){
      const cell = grid[r][c], tile = document.createElement('div');
      tile.className='tile'; tile.dataset.r=r; tile.dataset.c=c;
      if(cell.matched){ tile.classList.add('empty'); tile.classList.add('matched'); }
      if(cell.img){
        if(cell.img==="?"){ tile.innerHTML=`<div style="font-size:18px;color:#2b2b2b">?</div>`; }
        else { const img=document.createElement('img'); img.src=cell.img; img.alt=''; img.onerror=function(){ this.style.display='none'; }; tile.appendChild(img); }
      }
      tile.addEventListener('click', onTileClick);
      boardEl.appendChild(tile);
    }
  }
  resizeCanvas(); updateRemaining(); updateLevelUI();
}

// --- Remaining ---
function updateRemaining(){ 
  let cnt=0; for(let r=1;r<grid.length-1;r++) for(let c=1;c<grid[0].length-1;c++) if(!grid[r][c].matched) cnt++; 
  remainingEl.textContent=`Còn: ${cnt} ô — Lượt: ${moves}`;
}

// --- Level UI ---
function updateLevelUI(){
  prevLevelBtn.disabled = (level<=1);
  nextLevelBtn.disabled = (level+1>maxLevelUnlocked);
}

// --- Start / next level ---
function applyLevel(lv){ level=lv; levelLabel.textContent=lv; rows = BASE_ROWS+(lv-1)*2; cols = BASE_COLS+(lv-1)*2; }
async function initializeBoard(){
  if(!availableImages.length) availableImages = await detectImages();
  const pairsList = preparePairsList(availableImages, rows*cols);
  grid = buildGrid(rows, cols, pairsList);
  renderBoard();
  autoShuffleIfStuck();
}
function startLevel(lv){
  if(lv>maxLevelUnlocked){ alert(`Bạn chưa mở level ${lv}. Hoàn thành level ${maxLevelUnlocked} trước.`); return; }
  applyLevel(lv);
  moves=0; hintLimit=3; shuffleLimit=3;
  initializeBoard();
}
function nextLevel(){ unlockLevel(level+1); startLevel(level+1); }

// --- Tile click ---
function onTileClick(e){
  if(busy) return;
  const el=e.currentTarget, r=+el.dataset.r, c=+el.dataset.c;
  if(grid[r][c].matched) return;
  if(!firstSel){ firstSel={r,c,el}; el.classList.add('selected'); return; }
  if(firstSel.r===r && firstSel.c===c){ firstSel.el.classList.remove('selected'); firstSel=null; return; }
  const a=firstSel,b={r,c,el}; a.el.classList.add('selected'); b.el.classList.add('selected'); moves++;
  const cellA=grid[a.r][a.c], cellB=grid[b.r][b.c];
  const same=(cellA.img && cellB.img && cellA.img===cellB.img) || (!cellA.img && !cellB.img);
  if(!same){ setTimeout(()=>{ a.el.classList.remove('selected'); b.el.classList.remove('selected'); firstSel=null; },350); return; }
  const path = findPath(a.r,a.c,b.r,b.c);
  if(path){
    busy=true; drawPath(path);
    setTimeout(()=>{
      a.el.classList.add('matched'); b.el.classList.add('matched');
      grid[a.r][a.c].matched=true; grid[b.r][b.c].matched=true;
      firstSel=null; renderBoard(); busy=false; updateRemaining();
      if(isWin()){ setTimeout(()=>{ alert(`Bạn đã hoàn thành level ${level}!`); nextLevel(); },100); }
    },260);
  } else setTimeout(()=>{ a.el.classList.remove('selected'); b.el.classList.remove('selected'); firstSel=null; },350);
}

// --- Pathfinding ≤2 turns ---
function findPath(r1,c1,r2,c2){
  if(r1===r2 && c1===c2) return null;
  const R=grid.length,C=grid[0].length,dirs=[{dr:-1,dc:0},{dr:0,dc:1},{dr:1,dc:0},{dr:0,dc:-1}],INF=999;
  const best=Array.from({length:R},()=>Array.from({length:C},()=>Array(4).fill(INF)));
  const q=[],parent=new Map(),key=s=>`${s.r},${s.c},${s.dir},${s.turns}`;
  for(let d=0;d<4;d++){ best[r1][c1][d]=0; q.push({r:r1,c:c1,dir:d,turns:0}); parent.set(key({r:r1,c:c1,dir:d,turns:0}),null); }
  while(q.length){
    const cur=q.shift();
    let nr=cur.r+dirs[cur.dir].dr,nc=cur.c+dirs[cur.dir].dc;
    while(nr>=0&&nr<R&&nc>=0&&nc<C){
      const cell=grid[nr][nc],occupied=!cell.matched,isTarget=(nr===r2&&nc===c2);
      if(occupied && !isTarget) break;
      if(best[nr][nc][cur.dir]>cur.turns){
        best[nr][nc][cur.dir]=cur.turns;
        parent.set(key({r:nr,c:nc,dir:cur.dir,turns:cur.turns}),key(cur));
        if(nr===r2&&nc===c2&&cur.turns<=2){ return reconstructPath(parent,{r:nr,c:nc,dir:cur.dir,turns:cur.turns},{r:r1,c:c1}); }
        if(cur.turns<2){ for(let nd=0;nd<4;nd++){ if(nd===cur.dir) continue; const nt=cur.turns+1; if(best[nr][nc][nd]>nt){ best[nr][nc][nd]=nt; parent.set(key({r:nr,c:nc,dir:nd,turns:nt}),key(cur)); q.push({r:nr,c:nc,dir:nd,turns:nt}); } } }
        q.push({r:nr,c:nc,dir:cur.dir,turns:cur.turns});
      }
      nr+=dirs[cur.dir].dr; nc+=dirs[cur.dir].dc;
    }
  }
  return null;
}
function reconstructPath(parentMap,endState,startPos){
  const key=s=>`${s.r},${s.c},${s.dir},${s.turns}`,pts=[];
  let curKey=key(endState);
  while(curKey){ const parts=curKey.split(',').map(Number); pts.push({r:parts[0],c:parts[1]}); curKey=parentMap.get(curKey); }
  if(pts.length===0||pts[pts.length-1].r!==startPos.r||pts[pts.length-1].c!==startPos.c) pts.push({r:startPos.r,c:startPos.c});
  pts.reverse(); const comp=[];
  for(const p of pts){ if(!comp.length){ comp.push(p); continue; } if(comp.length>=2){ const a=comp[comp.length-2],b=comp[comp.length-1]; const daR=b.r-a.r,daC=b.c-a.c,dbR=p.r-b.r,dbC=p.c-b.c; if(Math.sign(daR)===Math.sign(dbR)&&Math.sign(daC)===Math.sign(dbC)){ comp[comp.length-1]=p; } else comp.push(p); } else comp.push(p); }
  return comp;
}

// --- Draw path ---
function drawPath(points){
  resizeCanvas();
  const ctx=canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!points||points.length<2) return;
  const coords=points.map(p=>tileCenterXY(p.r,p.c));
  ctx.lineWidth=4; ctx.strokeStyle='rgba(255,213,74,0.98)'; ctx.fillStyle='rgba(255,213,74,0.98)';
  ctx.beginPath(); ctx.moveTo(coords[0].x,coords[0].y); for(let i=1;i<coords.length;i++) ctx.lineTo(coords[i].x,coords[i].y); ctx.stroke();
  for(const p of coords){ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); }
  setTimeout(()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); },420);
}
function tileCenterXY(r,c){
  const tile=boardEl.querySelector(`.tile[data-r='${r}'][data-c='${c}']`),stageRect=stage.getBoundingClientRect();
  if(!tile) return {x:0,y:0}; const tr=tile.getBoundingClientRect(); return { x:(tr.left-stageRect.left)+tr.width/2, y:(tr.top-stageRect.top)+tr.height/2 };
}

// --- Canvas resize ---
function resizeCanvas(){
  const rect=stage.getBoundingClientRect();
  canvas.width=rect.width*devicePixelRatio;
  canvas.height=rect.height*devicePixelRatio;
  canvas.style.width=rect.width+'px';
  canvas.style.height=rect.height+'px';
  const ctx=canvas.getContext('2d'); ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}

// --- Shuffle remaining ---
function shuffleRemaining(){
  if(shuffleLimit<=0){ alert("Bạn đã dùng hết lượt xáo."); return; }
  shuffleLimit--;
  const arr=[]; for(let r=1;r<grid.length-1;r++) for(let c=1;c<grid[0].length-1;c++) if(!grid[r][c].matched) arr.push(grid[r][c].img);
  shuffle(arr); let k=0; for(let r=1;r<grid.length-1;r++) for(let c=1;c<grid[0].length-1;c++) if(!grid[r][c].matched) grid[r][c].img=arr[k++];
  renderBoard();
}

// --- Hint ---
function findHint(){
  for(let r1=1;r1<grid.length-1;r1++){ for(let c1=1;c1<grid[0].length-1;c1++){
    const a=grid[r1][c1]; if(a.matched) continue;
    for(let r2=r1;r2<grid.length-1;r2++){ for(let c2=(r2===r1?c1+1:1);c2<grid[0].length-1;c2++){
      const b=grid[r2][c2]; if(b.matched) continue;
      const same=(a.img && b.img && a.img===b.img)||(!a.img&&!b.img);
      if(!same) continue; const p=findPath(r1,c1,r2,c2); if(p) return {a:{r:r1,c:c1},b:{r:r2,c:c2},path:p};
    }}
  }}
  return null;
}
function hasPossibleMove(){ return !!findHint(); }
function isWin(){ for(let r=1;r<grid.length-1;r++) for(let c=1;c<grid[0].length-1;c++) if(!grid[r][c].matched) return false; return true; }

// --- Auto shuffle if stuck ---
function autoShuffleIfStuck(){
  if(!hasPossibleMove()){ shuffleRemaining(); return true; } return false;
}

// --- Events ---
newBtn.onclick=()=>startLevel(level);
shuffleBtn.onclick=()=>shuffleRemaining();
hintBtn.onclick=()=>{
  if(hintLimit<=0){ alert("Bạn đã dùng hết lượt gợi ý"); return; }
  hintLimit--;
  const h=findHint(); if(!h){ alert("Không còn ô để gợi ý, tự xáo"); autoShuffleIfStuck(); return; }
  drawPath([h.a,h.b]);
};
prevLevelBtn.onclick=()=>{ if(level>1) startLevel(level-1); };
nextLevelBtn.onclick=()=>{ if(level+1<=maxLevelUnlocked) startLevel(level+1); };

// --- Init ---
startLevel(1);
window.addEventListener('resize',resizeCanvas);
</script>
</body>
</html>
