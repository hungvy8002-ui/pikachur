<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pikachur Classic — Levels (Web)</title>
<style>
  :root{
    --bg:#071024; --card:#0f1724; --accent:#ffd54a; --muted:#9aa4b2;
    --tile-size:72px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071025 0%, #0f1720 100%);color:#e6eef6}
  .wrap{max-width:1100px;margin:16px auto;padding:18px}
  header{display:flex;gap:12px;align-items:center}
  header img{height:56px}
  h1{font-size:20px;margin:0}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:12px 0}
  .controls input[type="number"]{width:64px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  button{background:var(--card);border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px 12px;border-radius:8px;cursor:pointer}
  button:hover{transform:translateY(-2px)}
  .board-wrap{background:rgba(255,255,255,0.02);padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);overflow-x:auto;}
  .board{display:grid;gap:8px;justify-items:center;padding:8px;grid-auto-rows: var(--tile-size); grid-auto-columns: var(--tile-size);}
  .tile{width:var(--tile-size);height:var(--tile-size);border-radius:8px;background:#fff;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.45);transition:transform .18s ease,opacity .18s ease; touch-action: manipulation;}
  .tile img{max-width:100%;max-height:100%;object-fit:contain;display:block}
  .tile.empty{background:transparent;box-shadow:none;cursor:default}
  .tile.matched{opacity:0;transform:scale(.6)}
  .tile.selected{outline:3px solid rgba(255,213,74,0.95);transform:translateY(-6px)}
  .hud{display:flex;gap:12px;align-items:center;margin-top:10px;color:var(--muted);flex-wrap:wrap}
  .muted{color:var(--muted)}
  #canvasLayer{position:absolute;left:0;top:0;pointer-events:none}
  .board-stage{position:relative}
  .levelBox{display:flex;gap:8px;align-items:center}
  .big{font-size:18px;font-weight:600}
  .controls .right{margin-left:auto;display:flex;gap:8px;align-items:center; flex-wrap:wrap;}
  .next-level{background:linear-gradient(90deg,#ffd54a,#ffb347);color:#07213a;border:none}
  @media (max-width:840px){
    :root{--tile-size:56px}
    .wrap{padding:12px}
    button{padding:6px 10px;font-size:14px;}
  }
  @media (max-width:480px){
    :root{--tile-size:44px}
    header img{height:40px}
    h1{font-size:16px}
    .controls{flex-direction: column; align-items: flex-start; gap:6px;}
    .controls .right{margin-left:0; flex-wrap: wrap;}
    button{padding:5px 8px; font-size:13px;}
    .muted{font-size:12px;}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <img src="assets/button/gameName.png" alt="game" onerror="this.style.display='none'"/>
      <div>
        <h1>Pikachur Classic — Levels</h1>
        <div class="muted">Connect-2 (≤2 góc). Tăng ô theo level. Không có âm nhạc.</div>
      </div>
    </header>

    <div class="controls">
      <div class="levelBox">
        <div class="muted">Level</div>
        <div id="levelLabel" class="big">1</div>
      </div>

      <div class="muted">Start size:</div>
      <div class="muted">6×8 → mỗi level +2 hàng +2 cột</div>

      <div class="controls right">
        <button id="prevLevelBtn">« Level trước</button>
        <button id="nextLevelBtn">Level tiếp →</button>
        <button id="newBtn">Tạo lại</button>
        <button id="shuffleBtn">Xáo (3)</button>
        <button id="hintBtn">Gợi ý (3)</button>
        <div id="remaining" class="muted">Còn: 0 ô</div>
      </div>
    </div>

    <div class="board-wrap">
      <div class="board-stage" id="stage">
        <canvas id="canvasLayer"></canvas>
        <div id="board" class="board"></div>
      </div>
    </div>

    <div class="hud">
      <div class="muted">Luật: chọn 2 ô giống nhau. Hai ô phải nối được bằng đường gồm ≤2 góc (không cắt ô khác).</div>
      <div class="muted">Nếu hết đường, hãy nhấn "Xáo".</div>
    </div>
  </div>

<script>
// Config
const BASE_ROWS = 6, BASE_COLS = 8, MAX_DETECT = 500;
const stage = document.getElementById('stage'), boardEl = document.getElementById('board');
const levelLabel = document.getElementById('levelLabel'), remainingEl = document.getElementById('remaining');
const newBtn = document.getElementById('newBtn'), shuffleBtn = document.getElementById('shuffleBtn');
const hintBtn = document.getElementById('hintBtn'), prevLevelBtn = document.getElementById('prevLevelBtn');
const nextLevelBtn = document.getElementById('nextLevelBtn'), canvas = document.getElementById('canvasLayer');

let level=1, rows=BASE_ROWS, cols=BASE_COLS, grid=[], moves=0;
let availableImages=[], firstSel=null, busy=false;
let hintLimit=3, shuffleLimit=3;

// Detect images
async function detectImages(){
  const arr=[];
  for(let i=1;i<=MAX_DETECT;i++){
    const p=`assets/images/pokemon/${i}.png`;
    try{ const r=await fetch(p,{method:'GET'}); if(r.ok) arr.push(p); }catch(e){}
  }
  return arr;
}

// Shuffle util
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

// Prepare pairs list
function preparePairsList(avail, cellCount){
  const pairs=Math.floor(cellCount/2), list=[];
  if(avail.length>=pairs){
    const pick=shuffle(avail.slice()).slice(0,pairs);
    for(let i=0;i<pick.length;i++){ list.push(pick[i]); list.push(pick[i]); }
  }else if(avail.length>0){
    let i=0; while(list.length<pairs*2){ list.push(avail[i%avail.length]); list.push(avail[i%avail.length]); i++; }
  }else{
    for(let i=0;i<pairs;i++){ list.push("?"); list.push("?"); }
  }
  return shuffle(list);
}

// Build grid
function buildGrid(rowsNoPad, colsNoPad, pairsList){
  const R=rowsNoPad+2, C=colsNoPad+2;
  const g=Array.from({length:R},()=>Array.from({length:C},()=>({img:null,matched:true})));
  let k=0;
  for(let r=1;r<=rowsNoPad;r++){
    for(let c=1;c<=colsNoPad;c++){
      g[r][c]={img:pairsList[k]===undefined?null:pairsList[k],matched:false};
      k++;
    }
  }
  return g;
}

// Render board
function renderBoard(){
  const innerRows=grid.length-2, innerCols=grid[0].length-2;
  boardEl.style.gridTemplateColumns=`repeat(${innerCols},1fr)`;
  boardEl.innerHTML='';
  for(let r=1;r<=innerRows;r++){
    for(let c=1;c<=innerCols;c++){
      const cell=grid[r][c], tile=document.createElement('div');
      tile.className='tile'; tile.dataset.r=r; tile.dataset.c=c;
      if(cell.matched){ tile.classList.add('empty'); tile.classList.add('matched');}
      if(cell.img){
        if(cell.img==="?"){ tile.innerHTML=`<div style="font-size:22px;color:#2b2b2b">?</div>`; }
        else{ const img=document.createElement('img'); img.src=cell.img; img.alt=''; img.onerror=function(){ this.style.display='none'; }; tile.appendChild(img); }
      }
      tile.addEventListener('click',onTileClick);
      boardEl.appendChild(tile);
    }
  }
  resizeCanvas();
  updateRemaining();
}

// Update remaining
function updateRemaining(){
  let cnt=0;
  for(let r=1;r<grid.length-1;r++) for(let c=1;c<grid[0].length-1;c++) if(!grid[r][c].matched) cnt++;
  remainingEl.textContent=`Còn: ${cnt} ô — Lượt: ${moves}`;
}

// Auto shuffle if stuck
function autoShuffleIfStuck(){
  if(!hasPossibleMove()){
    shuffleRemaining();
    console.log("Auto-shuffle vì không còn cặp nào");
    return true;
  }
  return false;
}

// Click logic
function onTileClick(e){
  if(busy) return;
  const el=e.currentTarget, r=+el.dataset.r, c=+el.dataset.c;
  if(grid[r][c].matched) return;
  if(!firstSel){ firstSel={r,c,el}; el.classList.add('selected'); return; }

  const a=firstSel, b={r,c,el}; a.el.classList.add('selected'); b.el.classList.add('selected'); moves++;
  const cellA=grid[a.r][a.c], cellB=grid[b.r][b.c];
  const same=(cellA.img && cellB.img && cellA.img===cellB.img) || (!cellA.img && !cellB.img);
  if(!same){ setTimeout(()=>{ a.el.classList.remove('selected'); b.el.classList.remove('selected'); firstSel=null; },350); return; }

  const path=findPath(a.r,a.c,b.r,b.c);
  if(path){
    busy=true; drawPath(path);
    setTimeout(()=>{
      a.el.classList.add('matched'); b.el.classList.add('matched');
      grid[a.r][a.c].matched=true; grid[b.r][b.c].matched=true;
      firstSel=null; renderBoard(); busy=false; updateRemaining();
      autoShuffleIfStuck(); // auto shuffle nếu k còn cặp
      if(isWin()){ setTimeout(()=>{ if(confirm('Bạn đã hoàn thành level '+level+'. Chuyển level tiếp?')) nextLevel(); },100); }
    },260);
  }else{ setTimeout(()=>{ a.el.classList.remove('selected'); b.el.classList.remove('selected'); firstSel=null; },350); }
}

// Pathfinding BFS ≤2 góc & các hàm khác giữ nguyên...
// ...

// Level logic
function applyLevel(lv){ level=lv; levelLabel.textContent=lv; rows=BASE_ROWS+(lv-1)*2; cols=BASE_COLS+(lv-1)*2; }
function startLevel(lv){ applyLevel(lv); moves=0; hintLimit=3; shuffleLimit=3; initializeBoard().then(()=>autoShuffleIfStuck()); }
async function initializeBoard(){
  if(!availableImages.length) availableImages=await detectImages();
  const cells=rows*cols, pairsList=preparePairsList(availableImages,cells);
  grid=buildGrid(rows,cols,pairsList); renderBoard();
  autoShuffleIfStuck();
}

// UI events
newBtn.addEventListener('click',()=>startLevel(level));
shuffleBtn.addEventListener('click',()=>{
  if(shuffleLimit>0){ shuffleRemaining(); shuffleLimit--; shuffleBtn.textContent=`Xáo (${shuffleLimit})`; }
  else alert("Bạn đã hết lượt xáo!");
});
hintBtn.addEventListener('click',()=>{
  if(hintLimit>0){
    const h=findHint();
    if(!h){ alert('Không tìm thấy cặp gợi ý. Hãy xáo bài.'); return; }
    const t1=boardEl.querySelector(`.tile[data-r='${h.a.r}'][data-c='${h.a.c}']`);
    const t2=boardEl.querySelector(`.tile[data-r='${h.b.r}'][data-c='${h.b.c}']`);
    if(t1&&t2){ t1.classList.add('selected'); t2.classList.add('selected'); drawPath(h.path); setTimeout(()=>{ t1.classList.remove('selected'); t2.classList.remove('selected'); },900); }
    hintLimit--; hintBtn.textContent=`Gợi ý (${hintLimit})`;
  }else alert("Bạn đã hết lượt gợi ý!");
});
prevLevelBtn.addEventListener('click',()=>{ if(level>1) startLevel(level-1); });
nextLevelBtn.addEventListener('click',()=>startLevel(level+1));
function nextLevel(){ startLevel(level+1); }
window.addEventListener('resize',resizeCanvas);

// Start first level
startLevel(1);
</script>
</body>
</html>
